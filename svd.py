#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys, fileinput, numpy

class Image:
	def __init__(self, matrix=[[]], width=0, height=0, depth=0):
		self.matrix = matrix
		self.width = width
		self.height = height
		self.depth = depth

	def set_width_and_height(self, width, height):
		self.width = width
		self.height = height
		self.matrix = [[0 for j in xrange(height)] for i in xrange(width)]


def write_matrices_to_file(matrixU, matrixS, matrixVt, kmin, kmax, filename, width, height, depth, rescale=False):
	"""
	Write a decomposed matrix to file uncompressed as it would show compressed

	Keyword Arguments:
	matrixU -- the U portion of the SVD
	matrixS -- the S (sigma) portion of the SVD
	matrixVt -- the V transpose portion of the SVD
	kmin -- the minimum k value to use for compresion (ignored if kmax = 0)
	kmax -- the maximum kvalue to use for compresion (find optimal if zero)
	filename -- the file to write to (stdout if blank)
	width -- the image width
	height -- the image height
	depth -- the maximum grey scale value (normally 255)
	rescale -- True to shift resulting image into 0 < n < depth bounds
	"""
	matrixScopy = matrixS.copy()
	# when kmax is not 0 use the provided kmax
	if kmax > 0:
		i = 0
		for t in numpy.nditer(matrixScopy, op_flags=['readwrite']):
			if i < kmin or i >= kmax:
				t[...] = 0
			i += 1
	# when kmax is 0 then drop eigen values less than 1.0E-14
	else:
		for t in numpy.nditer(matrixScopy, op_flags=['readwrite']):
			if round(t, 14) <= 0:
				t[...] = 0
	
	# recompose the trimmed SVD matrices back into matrix A
	A = numpy.dot(numpy.dot(matrixU, numpy.diag(matrixScopy)), matrixVt)

	# attempt the handle out of range values
	if rescale:
		curMin = 0
		curMax = 0
		# find min and max values
		for n in numpy.nditer(A):
			if int(round(n)) < curMin:
				curMin = int(round(n))
			if int(round(n)) > curMax:
				curMax = int(round(n))
		# shift values up
		if curMax < depth and curMin < 0:
			shiftVal = depth - curMax
			for t in numpy.nditer(A, op_flags=['readwrite']):
				t[...] = t + shiftVal
				if t > depth:
					t[...] = depth
				elif t < 0:
					t[...] = 0
		# shift values down
		elif curMax > depth and curMin > 0:
			shiftVal = curMin
			for t in numpy.nditer(A, op_flags=['readwrite']):
				t[...] = t - shiftVal
				if t > depth:
					t[...] = depth
				elif t < 0:
					t[...] = 0
		# no chance to shift, just chop (TODO: perform some sort of scaling)
		else:
			for t in numpy.nditer(A, op_flags=['readwrite']):
				if t > depth:
					t[...] = depth
				elif t < 0:
					t[...] = 0

	if filename:
		f = open(filename, 'w')
		f.write('P2\n')
		f.write('# Generated by Stoll \n')
		f.write(str(width))
		f.write(' ')
		f.write(str(height))
		f.write('\n')
		f.write(str(depth))
		f.write('\n')
		for n in numpy.nditer(A):
			f.write(str(int(round(n))))
			f.write(' ')
		f.write('\n')
		f.close()
	else:
		print 'P2'
		print '# Generated by Stoll'
		print str(width), ' ', str(height)
		print str(depth)
		for n in numpy.nditer(A):
			print str(int(round(n))),
		print


def read_matrix_from_file():
	"""
	Read an ASCII PGM file and create an Image object from it
	"""
	row = 0
	col = 0
	image = Image()
	for line in fileinput.input():
		if line[0] == '#':
			pass
		elif line[0] == 'P' and line[1] == '2':
			pass
		elif image.width == 0 and image.height == 0:
			x = 0
			y = 0
			x, y = [int(n) for n in line.split()]
			image.set_width_and_height(x, y)
		elif image.depth == 0:
			image.depth = int(line)
		else:
			for value in line.split():
				if col >= len(image.matrix[row]):
					row += 1
					col = 0
				image.matrix[row][col] = value
				col += 1
	return image
	

def process_file():
	"""
	Read from file provided on the command line or from stdin
	then save uncompressed representations of the SVD compressed version
	"""
	image = read_matrix_from_file()

	M = numpy.asmatrix(image.matrix)
	U, s, Vt = numpy.linalg.svd(M, full_matrices=True)
	
	write_matrices_to_file(U, s, Vt, 0, 0, 'out/a_0-0.pgm', image.width, image.height, image.depth)
	write_matrices_to_file(U, s, Vt, 0, 2, 'out/a_0-2.pgm', image.width, image.height, image.depth)
	write_matrices_to_file(U, s, Vt, 0, 4, 'out/a_0-4.pgm', image.width, image.height, image.depth)
	write_matrices_to_file(U, s, Vt, 1, 3, 'out/a_1-3.pgm', image.width, image.height, image.depth)


if __name__ == "__main__":
	if len(sys.argv) >= 2 and sys.argv[1] == "-?":
		print "Syntax: preprocess.py filename.csv"
		print " prints processed file to stdout in csv format"
	else:
		process_file()
